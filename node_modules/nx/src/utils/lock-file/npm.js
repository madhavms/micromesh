"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneNpmLockFile = exports.transitiveDependencyNpmLookup = exports.stringifyNpmLockFile = exports.parseNpmLockFile = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
/**
 * Parses package-lock.json file to `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function parseNpmLockFile(lockFile) {
    const _a = JSON.parse(lockFile), { packages, dependencies } = _a, metadata = tslib_1.__rest(_a, ["packages", "dependencies"]);
    return {
        dependencies: mapPackages(dependencies, packages, metadata.lockfileVersion),
        lockFileMetadata: Object.assign({ metadata }, (packages && { rootPackage: packages[''] })),
        hash: (0, utils_1.hashString)(lockFile),
    };
}
exports.parseNpmLockFile = parseNpmLockFile;
// Maps /node_modules/@abc/def with version 1.2.3 => @abc/def > @abc/dev@1.2.3
function mapPackages(dependencies, packages, lockfileVersion) {
    const mappedPackages = {};
    if (lockfileVersion === 1) {
        Object.entries(dependencies).forEach(([packageName, value]) => {
            const { newKey, packagePath } = prepareDependency(packageName, value.version, mappedPackages);
            mapPackageDependency(mappedPackages, packageName, newKey, packagePath, value, lockfileVersion, true);
            // we need to map the nested dependencies recursively
            mapPackageDependencies(mappedPackages, value.dependencies, packagePath, lockfileVersion);
        });
    }
    else {
        Object.entries(packages).forEach(([packagePath, value]) => {
            // we parse root package.json separately
            if (packagePath !== '') {
                const packageName = packagePath.split('node_modules/').pop();
                const { newKey } = prepareDependency(packageName, value.version, mappedPackages, undefined, packagePath);
                mapPackageDependency(mappedPackages, packageName, newKey, packagePath, value, lockfileVersion);
            }
        });
    }
    return mappedPackages;
}
function prepareDependency(packageName, version, mappedPackages, pathPrefix = '', path) {
    mappedPackages[packageName] = mappedPackages[packageName] || {};
    const newKey = packageName + '@' + version;
    const packagePath = path || pathPrefix
        ? `${pathPrefix}/node_modules/${packageName}`
        : `node_modules/${packageName}`;
    return { newKey, packagePath };
}
function mapPackageDependency(mappedPackages, packageName, key, packagePath, value, lockfileVersion, isRootVersion) {
    const packageMeta = {
        path: packagePath,
        dev: value.dev,
        optional: value.optional,
    };
    if (!mappedPackages[packageName][key]) {
        // const packageDependencies = lockfileVersion === 1 ? requires : dependencies;
        const rootVersion = isRootVersion !== null && isRootVersion !== void 0 ? isRootVersion : packagePath.split('/node_modules/').length === 1;
        if (lockfileVersion === 1) {
            const { requires } = value, rest = tslib_1.__rest(value, ["requires"]);
            if (requires) {
                rest.dependencies = requires;
            }
            value = rest;
        }
        mappedPackages[packageName][key] = Object.assign(Object.assign({}, value), { packageMeta: [], rootVersion });
    }
    mappedPackages[packageName][key].packageMeta.push(packageMeta);
}
function mapPackageDependencies(mappedPackages, dependencies, parentPath, lockfileVersion) {
    if (!dependencies) {
        return;
    }
    Object.entries(dependencies).forEach(([packageName, value]) => {
        const { newKey, packagePath } = prepareDependency(packageName, value.version, mappedPackages, parentPath);
        mapPackageDependency(mappedPackages, packageName, newKey, packagePath, value, lockfileVersion, false);
        mapPackageDependencies(mappedPackages, value.dependencies, packagePath, lockfileVersion);
    });
}
/**
 * Generates package-lock.json file from `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function stringifyNpmLockFile(lockFileData) {
    const notV1 = lockFileData.lockFileMetadata.metadata.lockfileVersion > 1;
    const notV3 = lockFileData.lockFileMetadata.metadata.lockfileVersion < 3;
    // initialize the lockfile collections
    const dependencies = {};
    const packages = Object.assign({}, (notV1 && { '': lockFileData.lockFileMetadata.rootPackage }));
    const keys = Object.keys(lockFileData.dependencies);
    for (let i = 0; i < keys.length; i++) {
        const packageName = keys[i];
        const packageVersions = lockFileData.dependencies[packageName];
        const values = Object.values(packageVersions);
        values.forEach((value) => {
            if (notV1) {
                unmapPackage(packages, value);
            }
            if (notV3) {
                unmapDependencies(dependencies, packageName, value);
            }
        });
    }
    // generate package lock JSON
    const lockFileJson = Object.assign(Object.assign(Object.assign({}, lockFileData.lockFileMetadata.metadata), (notV1 && {
        packages: (0, utils_1.sortObject)(packages, (value) => value, false, (a, b) => a.localeCompare(b)),
    })), (notV3 && { dependencies: sortDependencies(dependencies) }));
    return JSON.stringify(lockFileJson, null, 2) + '\n';
}
exports.stringifyNpmLockFile = stringifyNpmLockFile;
// remapping the package back to package-lock format
function unmapPackage(packages, dependency) {
    const { packageMeta, rootVersion, version, resolved, integrity } = dependency, value = tslib_1.__rest(dependency, ["packageMeta", "rootVersion", "version", "resolved", "integrity"]);
    // we need to decompose value, to achieve particular field ordering
    for (let i = 0; i < packageMeta.length; i++) {
        const { path } = packageMeta[i];
        // we are sorting the properties to get as close as possible to the original package-lock.json
        packages[path] = Object.assign({ version,
            resolved,
            integrity }, value);
    }
}
function unmapDependencies(dependencies, packageName, _a) {
    var { packageMeta } = _a, value = tslib_1.__rest(_a, ["packageMeta"]);
    const { version, resolved, integrity, devOptional } = value;
    for (let i = 0; i < packageMeta.length; i++) {
        const { path, dev, optional } = packageMeta[i];
        const projectPath = path.split('node_modules/').slice(1);
        const requires = unmapDependencyRequires(value);
        const innerDeps = getProjectNodeAndEnsureParentHierarchy(projectPath, dependencies);
        // sorting fields to match package-lock structure
        innerDeps[packageName] = Object.assign({ version,
            resolved,
            integrity,
            dev,
            devOptional,
            optional,
            requires }, innerDeps[packageName]);
    }
}
// generates/ensures entire parent hierarchy exists for the given project path
// returns pointer to last project in the path
function getProjectNodeAndEnsureParentHierarchy(projects, dependencies) {
    while (projects.length > 1) {
        const parentName = projects.shift().replace(/\/$/, '');
        if (!dependencies[parentName]) {
            dependencies[parentName] = {};
        }
        if (!dependencies[parentName].dependencies) {
            dependencies[parentName].dependencies = {};
        }
        dependencies = dependencies[parentName].dependencies;
    }
    return dependencies;
}
// combine dependencies and optionalDependencies into requires and sort them
function unmapDependencyRequires(value) {
    if (!value.dependencies && !value.optionalDependencies) {
        return undefined;
    }
    const dependencies = Object.assign(Object.assign({}, (value.dependencies || {})), (value.optionalDependencies || {}));
    const sortedKeys = Object.keys(dependencies).sort((a, b) => a.localeCompare(b));
    const result = {};
    for (let i = 0; i < sortedKeys.length; i++) {
        const key = sortedKeys[i];
        result[key] = dependencies[key];
    }
    return result;
}
// recursively sort dependencies
function sortDependencies(unsortedDependencies) {
    const dependencies = {};
    const sortedKeys = Object.keys(unsortedDependencies).sort((a, b) => a.localeCompare(b));
    for (let i = 0; i < sortedKeys.length; i++) {
        const value = unsortedDependencies[sortedKeys[i]];
        dependencies[sortedKeys[i]] = value;
        if (value.dependencies) {
            value.dependencies = sortDependencies(value.dependencies);
        }
    }
    return dependencies;
}
/**
 * Returns matching version of the dependency
 */
function transitiveDependencyNpmLookup(packageName, parentPackage, versions, version) {
    const nestedVersion = Object.values(versions).find((v) => v.packageMeta.some((p) => p.path.indexOf(`${parentPackage}/node_modules/${packageName}`) !== -1));
    if (nestedVersion) {
        return nestedVersion;
    }
    // otherwise search for the matching version
    return Object.values(versions).find((v) => v.rootVersion);
}
exports.transitiveDependencyNpmLookup = transitiveDependencyNpmLookup;
/**
 * Prunes the lock file data based on the list of packages and their transitive dependencies
 *
 * @param lockFileData
 * @returns
 */
function pruneNpmLockFile(lockFileData, packages) {
    // todo(meeroslav): This functionality has not been implemented yet
    console.warn('Pruning package-lock.json is not yet implemented. Returning entire lock file');
    return lockFileData;
}
exports.pruneNpmLockFile = pruneNpmLockFile;
//# sourceMappingURL=npm.js.map
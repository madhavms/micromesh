"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashExternalNodes = exports.mapExternalNodes = exports.getNodeName = exports.isRootVersion = exports.findMatchingVersion = exports.hashString = exports.sortObject = void 0;
const semver_1 = require("semver");
const hashing_impl_1 = require("../../hasher/hashing-impl");
const workspace_root_1 = require("../workspace-root");
const fs_1 = require("fs");
/**
 * Simple sort function to ensure keys are ordered alphabetically
 * @param obj
 * @returns
 */
function sortObject(obj, valueTransformator = (value) => value, descending = false, sortFunction) {
    const keys = Object.keys(obj);
    if (keys.length === 0) {
        return;
    }
    keys.sort(sortFunction);
    if (descending) {
        keys.reverse();
    }
    const result = {};
    keys.forEach((key) => {
        result[key] = valueTransformator(obj[key]);
    });
    return result;
}
exports.sortObject = sortObject;
/**
 * Apply simple hashing of the content using the default hashing implementation
 * @param fileContent
 * @returns
 */
function hashString(fileContent) {
    return hashing_impl_1.defaultHashing.hashArray([fileContent]);
}
exports.hashString = hashString;
function findMatchingVersion(packageName, packageVersions, version) {
    var _a;
    // if it's fixed version, just return it
    if (packageVersions[`${packageName}@${version}`]) {
        return version;
    }
    // otherwise search for the matching version
    return (_a = Object.values(packageVersions).find((v) => (0, semver_1.satisfies)(v.version, version))) === null || _a === void 0 ? void 0 : _a.version;
}
exports.findMatchingVersion = findMatchingVersion;
function isRootVersion(packageName, version) {
    const fullPath = `${workspace_root_1.workspaceRoot}/node_modules/${packageName}/package.json`;
    if ((0, fs_1.existsSync)(fullPath)) {
        const content = (0, fs_1.readFileSync)(fullPath, 'utf-8');
        return JSON.parse(content).version === version;
    }
    else {
        return false;
    }
}
exports.isRootVersion = isRootVersion;
/**
 * Returns node name depending whether it's root version or nested
 */
function getNodeName(dep, version, rootVersion) {
    return rootVersion ? `npm:${dep}` : `npm:${dep}@${version}`;
}
exports.getNodeName = getNodeName;
function mapExternalNodes(lockFileData, transitiveLookupFn) {
    const result = {
        dependencies: {},
        externalNodes: {},
        nodes: {},
    };
    const versionCache = {};
    Object.entries(lockFileData.dependencies).forEach(([packageName, versions]) => {
        Object.values(versions).forEach(({ version, rootVersion, dependencies, peerDependencies }) => {
            // save external node
            const nodeName = getNodeName(packageName, version, rootVersion);
            result.externalNodes[nodeName] = {
                type: 'npm',
                name: nodeName,
                data: {
                    version,
                    packageName,
                },
            };
            const combinedDependencies = dependencies || peerDependencies
                ? Object.assign(Object.assign({}, (dependencies || {})), (peerDependencies || {})) : undefined;
            if (combinedDependencies) {
                const nodeDependencies = [];
                const transitiveDeps = mapTransitiveDependencies(packageName, lockFileData.dependencies, combinedDependencies, versionCache, transitiveLookupFn);
                transitiveDeps.forEach((target) => {
                    nodeDependencies.push({
                        type: 'static',
                        source: nodeName,
                        target,
                    });
                });
                result.dependencies[nodeName] = nodeDependencies;
            }
        });
    });
    return result;
}
exports.mapExternalNodes = mapExternalNodes;
// Finds the maching version of each dependency of the package and
// maps each {package}:{versionRange} pair to "npm:{package}@{version}" (when transitive) or "npm:{package}" (when root)
function mapTransitiveDependencies(parentPackage, packages, dependencies, versionCache, transitiveLookupFn) {
    if (!dependencies) {
        return [];
    }
    const result = [];
    Object.keys(dependencies).forEach((packageName) => {
        var _a, _b;
        // some of the peer dependencies might not be installed,
        // we don't have them as nodes in externalNodes
        // so there's no need to map them as dependencies
        if (!packages[packageName]) {
            return;
        }
        // fix for pnpm versions that might have suffixes - `1.2.3_@babel+core@4.5.6`
        const cleanVersion = dependencies[packageName].split('_')[0];
        const key = `${packageName}@${cleanVersion}`;
        // if we already processed this dependency, use the version from the cache
        if (versionCache[key]) {
            result.push(versionCache[key]);
        }
        else {
            const version = packages[packageName][`${packageName}@${cleanVersion}`]
                ? cleanVersion
                : (_a = transitiveLookupFn(packageName, parentPackage, packages[packageName], cleanVersion)) === null || _a === void 0 ? void 0 : _a.version;
            // for some peer dependencies, we won't find installed version so we'll just ignore these
            if (version) {
                const nodeName = getNodeName(packageName, version, (_b = packages[packageName][`${packageName}@${version}`]) === null || _b === void 0 ? void 0 : _b.rootVersion);
                result.push(nodeName);
                versionCache[key] = nodeName;
            }
        }
    });
    return result;
}
function hashExternalNodes(projectGraph) {
    Object.keys(projectGraph.externalNodes).forEach((key) => {
        if (!projectGraph.externalNodes[key].data.hash) {
            // hash it using it's dependencies
            hashExternalNode(projectGraph.externalNodes[key], projectGraph);
        }
    });
}
exports.hashExternalNodes = hashExternalNodes;
function hashExternalNode(node, graph) {
    const hashKey = `${node.data.packageName}@${node.data.version}`;
    if (!graph.dependencies[node.name]) {
        node.data.hash = hashString(hashKey);
    }
    else {
        const hashingInput = [hashKey];
        traverseExternalNodesDependencies(node.name, graph, hashingInput);
        node.data.hash = hashing_impl_1.defaultHashing.hashArray(hashingInput.sort());
    }
}
function traverseExternalNodesDependencies(projectName, graph, visited) {
    graph.dependencies[projectName].forEach((d) => {
        const target = graph.externalNodes[d.target];
        const targetKey = `${target.data.packageName}@${target.data.version}`;
        if (visited.indexOf(targetKey) === -1) {
            visited.push(targetKey);
            if (graph.dependencies[d.target]) {
                traverseExternalNodesDependencies(d.target, graph, visited);
            }
        }
    });
}
//# sourceMappingURL=utils.js.map